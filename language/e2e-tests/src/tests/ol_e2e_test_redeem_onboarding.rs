use crate::executor::FakeExecutor;
use crate::account::{Account, AccountData, lbr_currency_code, AccountTypeSpecifier};
use crate::redeem_setup:: {redeem_txn, redeem_txn_onboarding};
use ol_miner::delay::delay;
use libra_types::transaction::TransactionStatus;
use libra_types::vm_error::{VMStatus, StatusCode};
use move_core_types::account_address::AccountAddress;
use hex;

#[test]
fn submit_proofs_transaction_onboarding() {
    // TODO: This is using the Fake Executor, like all the other e2e tests. Is there a way to use a libra-swarm node?
    let mut executor = FakeExecutor::from_genesis_file();

    //TODO: test this is not an association account.
    let account = Account::new_genesis_account(libra_types::on_chain_config::config_address() );
    let sequence_number = 10u64;
    let sender = AccountData::with_account(
        account,
        1_000_000,
        lbr_currency_code(),
        sequence_number,
        AccountTypeSpecifier::Empty
    );

    executor.add_account_data(&sender);

    println!("address:{:?}", sender.address() );

    let challenge = hex::decode("5ffd9856978b5020be7f72339e41a401000000000000000000000000deadbeef0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004f6c20746573746e65746400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070726f74657374732072616765206163726f737320416d6572696361");
    let challenge = challenge.unwrap();
    let expected_addess = [0u8; AccountAddress::LENGTH];
    let expected_addess = AccountAddress::new(expected_addess);
    let difficulty = 100u64;
    let auth_key_prefix = hex::decode("5ffd9856978b5020be7f72339e41a401000000000000000000000000deadbeef");
    let auth_key_prefix = auth_key_prefix.unwrap();
    // Generate solutions with cd ./verfiable-delay/ cargo run -- -l=4096 aa 100
    // the -l=4096 is important because this is the security paramater of 0L miner.
    // let proof_computed = delay::do_delay(challenge, difficulty);
    use crate::account::Account;
    use libra_types::transaction::{SignedTransaction, TransactionArgument};
    use stdlib::transaction_scripts::StdlibScript;
    use crate::gas_costs;
    use libra_types::account_config::LBR_NAME;
    use move_core_types::account_address::AccountAddress;
    
    /// This is test infrastructure. Helps build a signed transaction script of the Redeem module.
    pub fn redeem_txn(sender: &Account, seq_num: u64, challenge: Vec<u8>, difficulty: u64, solution: Vec<u8>, tower_height: u64 ) -> SignedTransaction {
        let args = vec![
            TransactionArgument::U8Vector(challenge),
            TransactionArgument::U64(difficulty),
            TransactionArgument::U8Vector(solution),
            TransactionArgument::U64(tower_height),
    
        ];
        sender.create_signed_txn_with_args(
            StdlibScript::Redeem
                .compiled_bytes()
                .into_vec(),
            vec![],
            args,
            seq_num,
            gas_costs::TXN_RESERVED,
            0,
            LBR_NAME.to_owned(),
        )
    }
    
    pub fn redeem_txn_onboarding(sender: &Account, seq_num: u64, challenge: Vec<u8>, difficulty: u64, solution: Vec<u8>, expected_address: AccountAddress) -> SignedTransaction {
        let args = vec![
            TransactionArgument::U8Vector(challenge),
            TransactionArgument::U64(difficulty),
            TransactionArgument::U8Vector(solution),
            TransactionArgument::Address(expected_address),
        ];
        sender.create_signed_txn_with_args(
            StdlibScript::RedeemOnboarding
                .compiled_bytes()
                .into_vec(),
            vec![],
            args,
            seq_num,
            gas_costs::TXN_RESERVED * 4,
            0,
            LBR_NAME.to_owned(),
        )
    }
    
    // I copied this in from the json but haven't deleted the old one yet.
    let proof = hex::decode("000c1c21efba97d307e99592448e30170526d377b3d4931e71ac62e894cf727273481fea358fda15ab171a430a9362808912225ca713489e1649b704a211a0c816c3cfc07ddab099fcf11eea7a08eca3308c83a50a506683fb91e63688627feba16e80db72903e5a7d2305deb3150a3bff60b197efee29507f6e661c1c966df94964bebf4f56120f83563df5ec3d9a6e0851f4db74670ab73181b8acbf71153035c53da099333e570b8fdb884b90119d3c2aef97c282f7ee3ea16252adb60038c3dd3be2a3ec12d9aeb7e2a191e98eca92e3dbe4ff386fa77085e54bf4c6729d0f4cde66d50db7f03cef6c271c5df6545c15c562afd37f7dfc66410b2f1370ae620005908a15d190b30da558fd3bfc6417e081087462d897d0823fe2e20bdea89aaf8285e5da9dadccdb1ba6500bbba9e636f9101497610479eedf9c18ccf6c29866c806870731361387d6f810a60294507a24917b9812fa5f5160d53c7bb3adc9d8f81bfdae81ac77e8df85d779538b7be52ef3e2489d0ef0ef49cee05aac26d3e915e9bd0640d8635e812a80277245e6e285d971846d903fd0716097414692c08907d248f27b1de975c70180a454b677fe631f19276a1fb925fea654fef3fddbd8c07b4915442b4216bc39993d41117bff637ccca807818197c5b280efaa6c5a1c74adee08834b37c17799c6fa3123f80b0cfb0c73a4dd745375a23725459a3cad00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001");
    let proof = proof.unwrap();
    // let proof = hex::decode("005c9ee73ddaa19d050bc9944ac9ae5a16043fda1d0b20bfce0f7e18c1f7608eafb1e25b1fcf1e55cef3728bdcc695ecd51dcfafe297aa35a945d47e7b20266f501b0b7f636cd85f82a40cff7b57dfa96a521ff49f6daee00e65e1f44634443b818c088f40ef8dcb6cf4b0bdef336dd4c51aca0d6100e0acdcbd9bf26891a92e501bed6809762e0825624c82fbc38a692eac18457c0d74c126cfb62bdb665ee51a812758fc702865798b9f9cdb8d8236d068192f3f99df988f5ea55206353e0a54ca763350aae3ee10f4188c607e426fc52e7aa122b7df4b18cf2d0d50e964e3a721d83d4b9fee3090414965dfce75cd74c96fedcc269bc6baaf2a218865f1e63bffb02ac54d3e03d9018ec05a383a8b6acfc30d5e14db766d6cf01d5bc01a53ea9c0e55438b6eb9c3eba10682787aa1f57f75dfe69763e905b330b21bb6c8c0fb29327fe2085cfcbff7dd564e32ec2bcec261786d9598590c9abde29a96da79b56bb7bf171b413d3cd24b31b70df6b6488dd3cc4a5b26adced63f9e791b59c9ff3d7efff3fea92198d287287fd4f8f7b39917a6b7d8a53d4406bf41479560135deab1921c760b9480f16de2466bdbbb9ddd1a4fb2ea8f9378850064ba71ce01ea93f74aefb1bb7687c6cfc6f7fa8e492d611ac4a19a18309eb860d2c7b5f574b8d1b38132738946a5bbbb767352d58d2de16365e813665aa9921a9edec49dacabe500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001").unwrap();
    // assert_eq!(proof_computed, proof.clone());

    //run the transaction script
    let output = executor.execute_and_apply(
        // build the transaction script binary.
        redeem_txn_onboarding(
            &sender.account(),
            sequence_number,
            challenge.to_vec(),
            difficulty,
            proof.to_vec(),
            expected_addess)
    );

    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(VMStatus::new(StatusCode::EXECUTED))
    );
}
