use crate::executor::FakeExecutor;
use crate::account::{Account, AccountData, lbr_currency_code, AccountTypeSpecifier};
use crate::redeem_setup:: {redeem_txn, redeem_txn_onboarding};
use ol_miner::delay::delay;
use libra_types::transaction::TransactionStatus;
use libra_types::vm_error::{VMStatus, StatusCode};
use move_core_types::account_address::AccountAddress;
use hex;

#[test]
fn submit_proofs_transaction_onboarding() {
    // TODO: This is using the Fake Executor, like all the other e2e tests. Is there a way to use a libra-swarm node?
    let mut executor = FakeExecutor::from_genesis_file();

    //TODO: test this is not an association account.
    let account = Account::new_genesis_account(libra_types::on_chain_config::config_address() );
    let sequence_number = 10u64;
    let sender = AccountData::with_account(
        account,
        1_000_000,
        lbr_currency_code(),
        sequence_number,
        AccountTypeSpecifier::Empty
    );

    executor.add_account_data(&sender);

    println!("address:{:?}", sender.address() );

    let challenge = hex::decode("5ffd9856978b5020be7f72339e41a4015ffd9856978b5020be7f72339e41a40100000000000000000000000000000000000000000000000000000000000000000000000000004f6c20746573746e6574640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070726f74657374732072616765206163726f737320416d6572696361").unwrap();
    let expected_addess = "0x5ffd9856978b5020be7f72339e41a401"; //should be hex literal, no need to decode.
    let difficulty = 100u64;
    let auth_key_prefix = hex::decode("5ffd9856978b5020be7f72339e41a40100000000000000000000000000000000").unwrap();
    // Generate solutions with cd ./verfiable-delay/ cargo run -- -l=4096 aa 100
    // the -l=4096 is important because this is the security paramater of 0L miner.
    // let proof_computed = delay::do_delay(challenge, difficulty);

    // I copied this in from the json but haven't deleted the old one yet.
    let proof = hex::decode("0004c4f5a4c600050c67a3c8a87b8541c1be136b9565966ff6366a8670ea138f2c24718bbbafbb317ae49e83ab449deaad5fe6e8ae44c3ec13d94021f74cb22561eeb820ca8324e7fd49e27fc5b19111928c8a559411cf4a00565e975a05ee244dae8676803a2b4b57193039be79e23010ef97edba9060ef463f44061889f78bae5c4b1ecc2a27bbe9706bdda00d1de2487d6ffb6cd19cd7f562bd0b6cd78ab0b470da59135899a0233e2cca5c37839a9ea1470c0dd349a783b62fc882c3011a9a3f58d51d899855427255ebd7c92bf68fc863790ef71750a639614d9263b0731596fe435d834be77d0bc6a3c8a6de092219ab40ada39aaf59b83c6b5739c11650fffca5f0afcfb2ce7e34add26bd634ed9fcefa1dcf61547f5aa3a2b593a47622fd12c3310f5697fff9504ef3b877e927aebd15c5e8fe262c1efd5cb57e0c6c0f8e604345ef0d471ef51b57fcbe30a6744fe84f41409b003c751d6e408a94bcfb283f23b6090c98f4376c8e11c0defbbedce6146415ac19fe9e96f5a46e5100120628486742921ecb8741ccc811fff53f3e2fe85c92f7e7cf8cc34b1cad0404de0b378401f5a585753101be0c744f6c7eb06c3829f39382aaeadfc148dd3cfd73f5092b932828849918ceff4d72293a96315dd02da6754e71040a458e7e9088ef75cce75cb706b7cca022a019bea71a4bfab226972335724e566c5be8aca3230c5300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001").unwrap();

    let tower_height = 1u64;
    //run the transaction script
    let output = executor.execute_and_apply(
        // build the transaction script binary.
        redeem_txn_onboarding(
            &sender.account(),
            sequence_number,
            challenge,
            // auth_key_prefix,
            difficulty,
            proof,
            // tower_height,
            AccountAddress::from_hex_literal(expected_addess).unwrap())
    );

    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(VMStatus::new(StatusCode::EXECUTED))
    );
}
